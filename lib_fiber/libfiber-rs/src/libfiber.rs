/* automatically generated by rust-bindgen 0.59.2 */

pub const __GNUC_VA_LIST: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const TIME_UTC: u32 = 1;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLRDNORM: u32 = 64;
pub const POLLWRNORM: u32 = 4;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRBAND: u32 = 256;
pub const POLLEXTEND: u32 = 512;
pub const POLLATTRIB: u32 = 1024;
pub const POLLNLINK: u32 = 2048;
pub const POLLWRITE: u32 = 4096;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const POLLSTANDARD: u32 = 511;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: i32 = -1;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: i32 = -1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: i32 = -1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_DONTFRAG: u32 = 28;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &[u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_ADDR_MC_FLAGS_TRANSIENT: u32 = 16;
pub const IPV6_ADDR_MC_FLAGS_PREFIX: u32 = 32;
pub const IPV6_ADDR_MC_FLAGS_UNICAST_BASED: u32 = 48;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_ULA_USETEMPADDR: u32 = 51;
pub const IPV6CTL_MAXID: u32 = 51;
pub const _PATH_HEQUIV: &[u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 14usize] = b"/etc/networks\0";
pub const _PATH_PROTOCOLS: &[u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 14usize] = b"/etc/services\0";
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 4096;
pub const AI_ALL: u32 = 256;
pub const AI_V4MAPPED_CFG: u32 = 512;
pub const AI_ADDRCONFIG: u32 = 1024;
pub const AI_V4MAPPED: u32 = 2048;
pub const AI_DEFAULT: u32 = 1536;
pub const AI_UNUSABLE: u32 = 268435456;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_NUMERICSCOPE: u32 = 256;
pub const NI_DGRAM: u32 = 16;
pub const NI_WITHSCOPEID: u32 = 32;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const INVALID_SOCKET: i32 = -1;
pub const FIBER_ETIMEDOUT: u32 = 60;
pub const FIBER_ENOMEM: u32 = 12;
pub const FIBER_EINVAL: u32 = 22;
pub const FIBER_ECONNREFUSED: u32 = 61;
pub const FIBER_ECONNRESET: u32 = 54;
pub const FIBER_EHOSTDOWN: u32 = 64;
pub const FIBER_EHOSTUNREACH: u32 = 65;
pub const FIBER_EINTR: u32 = 4;
pub const FIBER_EAGAIN: u32 = 35;
pub const FIBER_ENETDOWN: u32 = 50;
pub const FIBER_ENETUNREACH: u32 = 51;
pub const FIBER_ENOTCONN: u32 = 57;
pub const FIBER_EISCONN: u32 = 56;
pub const FIBER_EWOULDBLOCK: u32 = 35;
pub const FIBER_ENOBUFS: u32 = 55;
pub const FIBER_ECONNABORTED: u32 = 53;
pub const FIBER_EINPROGRESS: u32 = 36;
pub const FIBER_EVENT_KERNEL: u32 = 0;
pub const FIBER_EVENT_POLL: u32 = 1;
pub const FIBER_EVENT_SELECT: u32 = 2;
pub const FIBER_EVENT_WMSG: u32 = 3;
pub const FIBER_FLAG_USE_MUTEX: u32 = 1;
pub const FIBER_FLAG_USE_FATAL: u32 = 2;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type acl_handle_t = isize;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU16>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU32>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSUnalignedU64>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type size_t = __darwin_size_t;
pub type ssize_t = __darwin_ssize_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcif as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcaddrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_dstaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_dstaddrlen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddrlen)
        )
    );
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<so_np_extensions>())).npx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<so_np_extensions>())).npx_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockproto>())).sp_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockproto>())).sp_protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_protocol)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).headers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).hdr_cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(hdr_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).trailers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).trl_cnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trl_cnt)
        )
    );
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut size_t,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    assert_eq!(
        ::std::mem::size_of::<timeval64>(),
        16usize,
        concat!("Size of: ", stringify!(timeval64))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval64>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval64>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval64>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).tick as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).tickadj as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tickadj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).stathz as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(stathz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockinfo>())).profhz as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(profhz)
        )
    );
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        arg1: ::std::os::raw::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
pub type sigset_t = __darwin_sigset_t;
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(revents)
        )
    );
}
pub type nfds_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn poll(
        arg1: *mut pollfd,
        arg2: nfds_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<accessx_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<accessx_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<accessx_descriptor>())).ad_name_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_name_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<accessx_descriptor>())).ad_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<accessx_descriptor>())).ad_pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_pad)
        )
    );
}
extern "C" {
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        arg2: size_t,
        arg3: *mut ::std::os::raw::c_int,
        arg4: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtempat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__msfilterreq>())).msfr_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__msfilterreq>())).msfr_fmode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__msfilterreq>())).msfr_nsrcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_nsrcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__msfilterreq>())).__msfr_align as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(__msfr_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__msfilterreq>())).msfr_group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__msfilterreq>())).msfr_srcs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_srcs)
        )
    );
}
extern "C" {
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__u6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__u6_addr)
        )
    );
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_ifindex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_mtu as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut h_errno: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addr_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_net as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_port as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_proto as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_proto as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_socktype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_canonname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(
        ::std::mem::size_of::<rpcent>(),
        24usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::std::mem::align_of::<rpcent>(),
        8usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_number as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_number)
        )
    );
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn freeaddrinfo(arg1: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn getaddrinfo(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const addrinfo,
        arg4: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(arg1: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn getnameinfo(
        arg1: *const sockaddr,
        arg2: socklen_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
        arg5: *mut ::std::os::raw::c_char,
        arg6: socklen_t,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyaddr(arg1: u32, arg2: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(arg1: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getprotobyname(arg1: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(arg1: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getservbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn sethostent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setnetent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setprotoent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setservent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn freehostent(arg1: *mut hostent);
}
extern "C" {
    pub fn gethostbyname2(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getipnodebyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getipnodebyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getrpcbyname(name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn setrpcent(stayopen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn herror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn innetgr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetgrent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn setnetgrent(arg1: *const ::std::os::raw::c_char);
}
pub type socket_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_ATTR {
    pub oflag: ::std::os::raw::c_uint,
    pub stack_size: size_t,
}
#[test]
fn bindgen_test_layout_ACL_FIBER_ATTR() {
    assert_eq!(
        ::std::mem::size_of::<ACL_FIBER_ATTR>(),
        16usize,
        concat!("Size of: ", stringify!(ACL_FIBER_ATTR))
    );
    assert_eq!(
        ::std::mem::align_of::<ACL_FIBER_ATTR>(),
        8usize,
        concat!("Alignment of ", stringify!(ACL_FIBER_ATTR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACL_FIBER_ATTR>())).oflag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACL_FIBER_ATTR),
            "::",
            stringify!(oflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACL_FIBER_ATTR>())).stack_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACL_FIBER_ATTR),
            "::",
            stringify!(stack_size)
        )
    );
}
extern "C" {
    pub fn acl_fiber_attr_init(attr: *mut ACL_FIBER_ATTR);
}
extern "C" {
    pub fn acl_fiber_attr_setstacksize(attr: *mut ACL_FIBER_ATTR, size: size_t);
}
extern "C" {
    pub fn acl_fiber_attr_setsharestack(attr: *mut ACL_FIBER_ATTR, on: ::std::os::raw::c_int);
}
pub type FIBER_ALLOC_FN = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ACL_FIBER)>,
        arg2: *const ACL_FIBER_ATTR,
    ) -> *mut ACL_FIBER,
>;
pub type FIBER_ORIGIN_FN = ::std::option::Option<unsafe extern "C" fn() -> *mut ACL_FIBER>;
extern "C" {
    pub fn acl_fiber_register(alloc_fn: FIBER_ALLOC_FN, origin_fn: FIBER_ORIGIN_FN);
}
extern "C" {
    pub fn acl_fiber_alloc(size: size_t, pptr: *mut *mut ::std::os::raw::c_void) -> *mut ACL_FIBER;
}
extern "C" {
    #[doc = " Set flag if the system API should be hooked, default value is 1 internal"]
    #[doc = " @param onoff {int} if need to hook the system API"]
    pub fn acl_fiber_hook_api(onoff: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the global flag that if in non-blocking status, just for windows"]
    #[doc = " @param yes {int} set in non-blocking status global if yes not 0"]
    pub fn acl_fiber_set_non_blocking(yes: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the shared stack's memory size in shared stack mode"]
    #[doc = " @param size {size_t} must more than 1024 for shared stack mode."]
    pub fn acl_fiber_set_shared_stack_size(size: size_t);
}
extern "C" {
    #[doc = " Get the shared stack's memory size if shared stack was enabled"]
    #[doc = " @return {size_t} return > 0 if shared stack was enabled, or return 0."]
    pub fn acl_fiber_get_shared_stack_size() -> size_t;
}
extern "C" {
    #[doc = " Create and start one fiber"]
    #[doc = " @param fn {void (*)(ACL_FIBER*, void*)} the callback of fiber running"]
    #[doc = " @param arg {void*} the second parameter of the callback fn"]
    #[doc = " @param size {size_t} the virual memory size of the fiber created"]
    #[doc = " @return {ACL_FIBER*}"]
    pub fn acl_fiber_create(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ACL_FIBER, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ACL_FIBER;
}
extern "C" {
    pub fn acl_fiber_create2(
        attr: *const ACL_FIBER_ATTR,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ACL_FIBER, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ACL_FIBER;
}
extern "C" {
    #[doc = " Get the fibers count in deading status"]
    #[doc = " @return {unsigned}"]
    pub fn acl_fiber_ndead() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the fibers count in aliving status"]
    #[doc = " @return {unsigned}"]
    pub fn acl_fiber_number() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Create one fiber in background for freeing the dead fibers, specify the"]
    #[doc = " maximum fibers in every recyling process"]
    #[doc = " @param max {size_t} the maximum fibers to freed in every recyling process"]
    pub fn acl_fiber_check_timer(max: size_t);
}
extern "C" {
    #[doc = " Get the current running fiber"]
    #[doc = " @retur {ACL_FIBER*} if no running fiber NULL will be returned"]
    pub fn acl_fiber_running() -> *mut ACL_FIBER;
}
extern "C" {
    #[doc = " If the fiber using shared stack?"]
    #[doc = " @param fiber {const ACL_FIBER*}"]
    #[doc = " @return {int} return 0 if using private stack, or the shared stack was used"]
    pub fn acl_fiber_use_share_stack(fiber: *const ACL_FIBER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the fiber ID of the specified fiber"]
    #[doc = " @param fiber {const ACL_FIBER*} the specified fiber object"]
    #[doc = " @return {unsigned int} return the fiber ID"]
    pub fn acl_fiber_id(fiber: *const ACL_FIBER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the current running fiber's ID"]
    #[doc = " @return {unsigned int} the current fiber's ID"]
    pub fn acl_fiber_self() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Set the error number to the specified fiber object"]
    #[doc = " @param fiber {ACL_FIBER*} the specified fiber, if NULL the current running"]
    #[doc = "  fiber will be used"]
    #[doc = " @param errnum {int} the error number"]
    pub fn acl_fiber_set_errno(fiber: *mut ACL_FIBER, errnum: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the error number of assosiated fiber"]
    #[doc = " @param fiber {ACL_FIBER*} the specified fiber, if NULL the current running"]
    #[doc = " @return {int} get the error number of assosiated fiber"]
    pub fn acl_fiber_errno(fiber: *mut ACL_FIBER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @deprecated"]
    #[doc = " @param fiber {ACL_FIBER*}"]
    #[doc = " @param yesno {int}"]
    pub fn acl_fiber_keep_errno(fiber: *mut ACL_FIBER, yesno: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the assosiated fiber's status"]
    #[doc = " @param fiber {ACL_FIBER*} the specified fiber, if NULL the current running"]
    #[doc = " @return {int}"]
    pub fn acl_fiber_status(fiber: *const ACL_FIBER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Kill the suspended fiber and notify it to exit"]
    #[doc = " @param fiber {const ACL_FIBER*} the specified fiber, NOT NULL"]
    pub fn acl_fiber_kill(fiber: *mut ACL_FIBER);
}
extern "C" {
    #[doc = " Check if the specified fiber has been killed"]
    #[doc = " @param fiber {ACL_FIBER*} the specified fiber, if NULL the current running"]
    #[doc = " @return {int} non zero returned if been killed"]
    pub fn acl_fiber_killed(fiber: *mut ACL_FIBER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the specified fiber has been signaled"]
    #[doc = " @param fiber {ACL_FIBER*} the specified fiber, if NULL the current running"]
    #[doc = " @return {int} non zero returned if been signed"]
    pub fn acl_fiber_signaled(fiber: *mut ACL_FIBER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the specified fiber's socket has been closed by another fiber"]
    #[doc = " @param fiber {ACL_FIBER*} the specified fiber, if NULL the current running"]
    #[doc = " @return {int} non zero returned if been closed"]
    pub fn acl_fiber_closed(fiber: *mut ACL_FIBER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the specified fiber has been canceled"]
    #[doc = " @param fiber {ACL_FIBER*} the specified fiber, if NULL the current running"]
    #[doc = " @return {int} non zero returned if been canceled"]
    pub fn acl_fiber_canceled(fiber: *mut ACL_FIBER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wakeup the suspended fiber with the assosiated signal number"]
    #[doc = " @param fiber {const ACL_FIBER*} the specified fiber, NOT NULL"]
    #[doc = " @param signum {int} SIGINT, SIGKILL, SIGTERM ... refer to bits/signum.h"]
    pub fn acl_fiber_signal(fiber: *mut ACL_FIBER, signum: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the signal number got from other fiber"]
    #[doc = " @param fiber {ACL_FIBER*} the specified fiber, if NULL the current running"]
    #[doc = " @retur {int} the signal number got"]
    pub fn acl_fiber_signum(fiber: *mut ACL_FIBER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Suspend the current running fiber"]
    #[doc = " @return {int}"]
    pub fn acl_fiber_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add the suspended fiber into resuming queue"]
    #[doc = " @param fiber {ACL_FIBER*} the fiber, NOT NULL"]
    pub fn acl_fiber_ready(fiber: *mut ACL_FIBER);
}
extern "C" {
    #[doc = " Suspend the current fiber and switch to run the next ready fiber"]
    pub fn acl_fiber_switch();
}
extern "C" {
    #[doc = " Set the fiber schedule process with automatically, in this way, when one"]
    #[doc = " fiber was created, the schedule process will start automatically, but only"]
    #[doc = " the first fiber was started, so you can create the other fibers in this"]
    #[doc = " fiber. The default schedule mode is non-automatically, you should call the"]
    #[doc = " acl_fiber_schedule or acl_fiber_schedule_with explicit"]
    pub fn acl_fiber_schedule_init(on: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Start the fiber schedule process, the fibers in the ready quque will be"]
    #[doc = " started in sequence."]
    pub fn acl_fiber_schedule();
}
extern "C" {
    pub fn acl_fiber_schedule_with(event_mode: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the event type, the default type is FIBER_EVENT_KERNEL, this function"]
    #[doc = " must be called before acl_fiber_schedule."]
    #[doc = " @param event_mode {int} the event type, defined as FIBER_EVENT_XXX"]
    pub fn acl_fiber_schedule_set_event(event_mode: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Check if the current thread is in fiber schedule status"]
    #[doc = " @return {int} non zero returned if in fiber schedule status"]
    pub fn acl_fiber_scheduled() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop the fiber schedule process, all fibers will be stopped"]
    pub fn acl_fiber_schedule_stop();
}
extern "C" {
    #[doc = " Let the current fiber sleep for a while"]
    #[doc = " @param milliseconds {unsigned int} the milliseconds to sleep"]
    #[doc = " @return {unsigned int} the rest milliseconds returned after wakeup"]
    pub fn acl_fiber_delay(milliseconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Let the current fiber sleep for a while"]
    #[doc = " @param seconds {unsigned int} the seconds to sleep"]
    #[doc = " @return {unsigned int} the rest seconds returned after wakeup"]
    pub fn acl_fiber_sleep(seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Create one fiber timer"]
    #[doc = " @param milliseconds {unsigned int} the timer wakeup milliseconds"]
    #[doc = " @param size {size_t} the virtual memory of the created fiber"]
    #[doc = " @param fn {void (*)(ACL_FIBER*, void*)} the callback when fiber wakeup"]
    #[doc = " @param ctx {void*} the second parameter of the callback fn"]
    #[doc = " @return {ACL_FIBER*} the new created fiber returned"]
    pub fn acl_fiber_create_timer(
        milliseconds: ::std::os::raw::c_uint,
        size: size_t,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ACL_FIBER, arg2: *mut ::std::os::raw::c_void),
        >,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut ACL_FIBER;
}
extern "C" {
    #[doc = " Reset the timer milliseconds time before the timer fiber wakeup"]
    #[doc = " @param timer {ACL_FIBER*} the fiber created by acl_fiber_create_timer"]
    #[doc = " @param milliseconds {unsigned int} the new timer wakeup milliseconds"]
    pub fn acl_fiber_reset_timer(timer: *mut ACL_FIBER, milliseconds: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Set the DNS service addr"]
    #[doc = " @param ip {const char*} ip of the DNS service"]
    #[doc = " @param port {int} port of the DNS service"]
    pub fn acl_fiber_set_dns(ip: *const ::std::os::raw::c_char, port: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the current fiber's local object"]
    #[doc = " @param key {int*} the addr of indexed key, its initial value should <= 0,"]
    #[doc = "  and one integer which > 0 will be set for it; the fiber local object will"]
    #[doc = "  be assosiated with the indexed key."]
    #[doc = " @param ctx {void *} the fiber local object"]
    #[doc = " @param free_fn {void (*)(void*)} the callback will be called before the"]
    #[doc = "  current fiber exiting"]
    #[doc = " @return {int} the integer value(>0) of indexed key returned, value less than"]
    #[doc = "  0 will be returned if no running fiber"]
    pub fn acl_fiber_set_specific(
        key: *mut ::std::os::raw::c_int,
        ctx: *mut ::std::os::raw::c_void,
        free_fn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current fiber's local object assosiated with the specified indexed key"]
    #[doc = " @param key {int} the integer value returned by acl_fiber_set_specific"]
    #[doc = " @retur {void*} NULL returned if no fiber local object with the specified key"]
    pub fn acl_fiber_get_specific(key: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
#[doc = " Log function type used in fiber logging process, should be set by the"]
#[doc = " function acl_fiber_msg_pre_write"]
#[doc = " @param ctx {void*} the user's context"]
#[doc = " @param fmt {const char*} format of parameters"]
#[doc = " @param ap {va_list} list of parameters"]
pub type FIBER_MSG_PRE_WRITE_FN = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ),
>;
#[doc = " Log function type used in fiber logging process, should be set by the"]
#[doc = " function acl_fiber_msg_register. This can be used by user for get the"]
#[doc = " logging information of fiber"]
#[doc = " @param ctx {void*} the user's context"]
#[doc = " @param fmt {const char*} format of parameters"]
#[doc = " @param ap {va_list} list of parameters"]
pub type FIBER_MSG_WRITE_FN = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ),
>;
extern "C" {
    #[doc = " Set the user's log saving function when process started"]
    #[doc = " @param write_fn {MSG_WRITE_FN} log function defined by the user"]
    #[doc = " @param ctx {void*} parameter will be transfered to write_fn"]
    pub fn acl_fiber_msg_register(write_fn: FIBER_MSG_WRITE_FN, ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Cleanup the registered log callback by acl_fiber_msg_register"]
    pub fn acl_fiber_msg_unregister();
}
extern "C" {
    #[doc = " Register the user's callback"]
    #[doc = " @param pre_write {MSG_PRE_WRITE_FN}"]
    #[doc = " @param ctx {void*}"]
    pub fn acl_fiber_msg_pre_write(
        pre_write: FIBER_MSG_PRE_WRITE_FN,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " If showing the fiber schedule process's log to stdout"]
    #[doc = " @param onoff {int} log will be showed to stdout if onoff isn't 0"]
    pub fn acl_fiber_msg_stdout_enable(onoff: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the system error number of last system API calling"]
    #[doc = " @return {int} error number"]
    pub fn acl_fiber_last_error() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the error information of last system API calling"]
    #[doc = " @return {const char*}"]
    pub fn acl_fiber_last_serror() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert errno to string"]
    #[doc = " @param errnum {int}"]
    #[doc = " @param buf {char*} hold the result"]
    #[doc = " @param size {size_t} buf's size"]
    #[doc = " @retur {const char*} the addr of buf"]
    pub fn acl_fiber_strerror(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the system error number"]
    #[doc = " @param errnum {int} the error number"]
    pub fn acl_fiber_set_error(errnum: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the fd limit for the current process"]
    #[doc = " @param limit {int} the fd limit to be set"]
    #[doc = " @return {int} the real fd limit will be returned"]
    pub fn acl_fiber_set_fdlimit(limit: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_gettimeofday(tv: *mut timeval, tz: *mut timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_memstat();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_MUTEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_RWLOCK {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create one fiber mutex, can only be used in the same thread"]
    #[doc = " @return {ACL_FIBER_MUTEX*} fiber mutex returned"]
    pub fn acl_fiber_mutex_create() -> *mut ACL_FIBER_MUTEX;
}
extern "C" {
    #[doc = " Free fiber mutex created by acl_fiber_mutex_create"]
    #[doc = " @param l {ACL_FIBER_MUTEX*} created by acl_fiber_mutex_create"]
    pub fn acl_fiber_mutex_free(l: *mut ACL_FIBER_MUTEX);
}
extern "C" {
    #[doc = " Lock the specified fiber mutex, return immediately when locked, or will"]
    #[doc = " wait until the mutex can be used"]
    #[doc = " @param l {ACL_FIBER_MUTEX*} created by acl_fiber_mutex_create"]
    pub fn acl_fiber_mutex_lock(l: *mut ACL_FIBER_MUTEX);
}
extern "C" {
    #[doc = " Try lock the specified fiber mutex, return immediately no matter the mutex"]
    #[doc = " can be locked."]
    #[doc = " @param l {ACL_FIBER_MUTEX*} created by acl_fiber_mutex_create"]
    #[doc = " @return {int} 0 returned when locking successfully, -1 when locking failed"]
    pub fn acl_fiber_mutex_trylock(l: *mut ACL_FIBER_MUTEX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The fiber mutex be unlock by its owner fiber, fatal will happen when others"]
    #[doc = " release the fiber mutex"]
    #[doc = " @param l {ACL_FIBER_MUTEX*} created by acl_fiber_mutex_create"]
    pub fn acl_fiber_mutex_unlock(l: *mut ACL_FIBER_MUTEX);
}
extern "C" {
    #[doc = " Create one fiber rwlock, can only be operated in the sampe thread"]
    #[doc = " @return {ACL_FIBER_RWLOCK*}"]
    pub fn acl_fiber_rwlock_create() -> *mut ACL_FIBER_RWLOCK;
}
extern "C" {
    #[doc = " Free rw mutex created by acl_fiber_rwlock_create"]
    #[doc = " @param l {ACL_FIBER_RWLOCK*} created by acl_fiber_rwlock_create"]
    pub fn acl_fiber_rwlock_free(l: *mut ACL_FIBER_RWLOCK);
}
extern "C" {
    #[doc = " Lock the rwlock, if there is no any write locking on it, the"]
    #[doc = " function will return immediately; otherwise, the caller will wait for all"]
    #[doc = " write locking be released. Read lock on it will successful when returning"]
    #[doc = " @param l {ACL_FIBER_RWLOCK*} created by acl_fiber_rwlock_create"]
    pub fn acl_fiber_rwlock_rlock(l: *mut ACL_FIBER_RWLOCK);
}
extern "C" {
    #[doc = " Try to locking the Readonly lock, return immediately no matter locking"]
    #[doc = " is successful."]
    #[doc = " @param l {ACL_FIBER_RWLOCK*} crated by acl_fiber_rwlock_create"]
    #[doc = " @retur {int} 1 returned when successfully locked, or 0 returned if locking"]
    #[doc = "  operation is failed."]
    pub fn acl_fiber_rwlock_tryrlock(l: *mut ACL_FIBER_RWLOCK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lock the rwlock in Write Lock mode, return until no any one locking it"]
    #[doc = " @param l {ACL_FIBER_RWLOCK*} created by acl_fiber_rwlock_create"]
    pub fn acl_fiber_rwlock_wlock(l: *mut ACL_FIBER_RWLOCK);
}
extern "C" {
    #[doc = " Try to lock the rwlock in Write Lock mode. return immediately no matter"]
    #[doc = " locking is successful."]
    #[doc = " @param l {ACL_FIBER_RWLOCK*} created by acl_fiber_rwlock_create"]
    #[doc = " @return {int} 1 returned when locking successfully, or 0 returned when"]
    #[doc = "  locking failed"]
    pub fn acl_fiber_rwlock_trywlock(l: *mut ACL_FIBER_RWLOCK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The rwlock's Read-Lock owner unlock the rwlock"]
    #[doc = " @param l {ACL_FIBER_RWLOCK*} crated by acl_fiber_rwlock_create"]
    pub fn acl_fiber_rwlock_runlock(l: *mut ACL_FIBER_RWLOCK);
}
extern "C" {
    #[doc = " The rwlock's Write-Lock owner unlock the rwlock"]
    #[doc = " @param l {ACL_FIBER_RWLOCK*} created by acl_fiber_rwlock_create"]
    pub fn acl_fiber_rwlock_wunlock(l: *mut ACL_FIBER_RWLOCK);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_EVENT {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create fiber event mutex which can be used in fibers mode or threads mode"]
    #[doc = " @param flag {unsigned} define as FIBER_FLAG_XXX above"]
    #[doc = " @return {ACL_FIBER_EVENT *}"]
    pub fn acl_fiber_event_create(flag: ::std::os::raw::c_uint) -> *mut ACL_FIBER_EVENT;
}
extern "C" {
    #[doc = " Free event mutex returned by acl_fiber_event_create"]
    #[doc = " @param {ACL_FIBER_EVENT *}"]
    pub fn acl_fiber_event_free(event: *mut ACL_FIBER_EVENT);
}
extern "C" {
    #[doc = " Wait for event can be available"]
    #[doc = " @param {ACL_FIBER_EVENT *}"]
    #[doc = " @return {int} 0 returned if successful, or -1 if error happened"]
    pub fn acl_fiber_event_wait(event: *mut ACL_FIBER_EVENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to wait for event can be available"]
    #[doc = " @param {ACL_FIBER_EVENT *}"]
    #[doc = " @return {int} 0 returned if successful, or -1 if the event been locked"]
    pub fn acl_fiber_event_trywait(event: *mut ACL_FIBER_EVENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The event's owner notify the waiters that the event mutex can be available,"]
    #[doc = " and the waiter will get the event mutex"]
    #[doc = " @param {ACL_FIBER_EVENT *}"]
    #[doc = " @return {int} 0 returned if successful, or -1 if error happened"]
    pub fn acl_fiber_event_notify(event: *mut ACL_FIBER_EVENT) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_COND {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create fiber cond which can be used in fibers more or threads mode"]
    #[doc = " @param flag {unsigned} current not used, just for the future extend"]
    #[doc = " @return {ACL_FIBER_COND *}"]
    pub fn acl_fiber_cond_create(flag: ::std::os::raw::c_uint) -> *mut ACL_FIBER_COND;
}
extern "C" {
    #[doc = " Free cond created by acl_fiber_cond_create"]
    #[doc = " @param cond {ACL_FIBER_COND *}"]
    pub fn acl_fiber_cond_free(cond: *mut ACL_FIBER_COND);
}
extern "C" {
    #[doc = " Wait for cond event to be signaled"]
    #[doc = " @param cond {ACL_FIBER_COND *}"]
    #[doc = " @param event {ACL_FIBER_EVENT *} must be owned by the current caller"]
    #[doc = " @return {int} return 0 if ok or return error value"]
    pub fn acl_fiber_cond_wait(
        cond: *mut ACL_FIBER_COND,
        event: *mut ACL_FIBER_EVENT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for cond event to be signaled with the specified timeout"]
    #[doc = " @param cond {ACL_FIBER_COND *}"]
    #[doc = " @return {int} return 0 if ok or return error value, when timedout ETIMEDOUT"]
    #[doc = "  will be returned"]
    pub fn acl_fiber_cond_timedwait(
        cond: *mut ACL_FIBER_COND,
        event: *mut ACL_FIBER_EVENT,
        delay_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Signal the cond which will wakeup one waiter for the cond to be signaled"]
    #[doc = " @param cond {ACL_FIBER_COND *}"]
    #[doc = " @return {int} return 0 if ok or return error value"]
    pub fn acl_fiber_cond_signal(cond: *mut ACL_FIBER_COND) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_FIBER_SEM {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create one fiber semaphore, and binding it with the current thread"]
    #[doc = " @param num {int} the initial value of the semaphore, must >= 0"]
    #[doc = " @return {ACL_FIBER_SEM *}"]
    pub fn acl_fiber_sem_create(num: ::std::os::raw::c_int) -> *mut ACL_FIBER_SEM;
}
extern "C" {
    #[doc = " Free fiber semaphore"]
    #[doc = " @param {ACL_FIBER_SEM *}"]
    pub fn acl_fiber_sem_free(sem: *mut ACL_FIBER_SEM);
}
extern "C" {
    pub fn acl_fiber_sem_get_tid(sem: *mut ACL_FIBER_SEM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Set the thread ID the semaphore belongs to, changing the owner of the fiber"]
    #[doc = " semaphore, when this function was called, the value of the semaphore must"]
    #[doc = " be zero, otherwise fatal will happen."]
    #[doc = " @param sem {ACL_FIBER_SEM*} created by acl_fiber_sem_create"]
    #[doc = " @param {unsigned long} the thread ID to be specificed with the semaphore"]
    pub fn acl_fiber_sem_set_tid(sem: *mut ACL_FIBER_SEM, tid: ::std::os::raw::c_ulong);
}
extern "C" {
    #[doc = " Wait for semaphore until > 0, semaphore will be -1 when returned"]
    #[doc = " @param sem {ACL_FIBER_SEM *} created by acl_fiber_sem_create"]
    #[doc = " @return {int} the semaphore value returned, if the caller's thread isn't"]
    #[doc = "  same as the semaphore owner's thread, -1 will be returned"]
    pub fn acl_fiber_sem_wait(sem: *mut ACL_FIBER_SEM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to wait semaphore until > 0, if semaphore is 0, -1 returned immediately,"]
    #[doc = " otherwise semaphore will be decreased 1 and the semaphore's value is returned"]
    #[doc = " @param sem {ACL_FIBER_SEM *} created by acl_fiber_sem_create"]
    #[doc = " @return {int} value(>=0) returned when waiting ok, otherwise -1 will be"]
    #[doc = "  returned if the caller's thread isn't same as the semaphore thread or the"]
    #[doc = "  semaphore's value is 0"]
    pub fn acl_fiber_sem_trywait(sem: *mut ACL_FIBER_SEM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add 1 to the semaphore, if there are other fibers waiting for semaphore,"]
    #[doc = " one waiter will be wakeuped"]
    #[doc = " @param sem {ACL_FIBER_SEM *} created by acl_fiber_sem_create"]
    #[doc = " @return {int} the current semaphore value returned, -1 returned if the"]
    #[doc = "  current thread ID is not same as the semaphore's owner ID"]
    pub fn acl_fiber_sem_post(sem: *mut ACL_FIBER_SEM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the specificed semaphore's value"]
    #[doc = " @param sem {ACL_FIBER_SEM*} created by acl_fiber_sem_create"]
    #[doc = " @retur {int} current semaphore's value returned"]
    pub fn acl_fiber_sem_num(sem: *mut ACL_FIBER_SEM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_socket(
        domain: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> socket_t;
}
extern "C" {
    pub fn acl_fiber_listen(
        arg1: socket_t,
        backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_close(fd: socket_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_accept(arg1: socket_t, arg2: *mut sockaddr, arg3: *mut socklen_t) -> socket_t;
}
extern "C" {
    pub fn acl_fiber_connect(
        arg1: socket_t,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_read(
        arg1: socket_t,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_readv(
        arg1: socket_t,
        iov: *const iovec,
        iovcnt: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_recvmsg(
        arg1: socket_t,
        msg: *mut msghdr,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_write(
        arg1: socket_t,
        buf: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_writev(
        arg1: socket_t,
        iov: *const iovec,
        iovcnt: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_sendmsg(
        arg1: socket_t,
        msg: *const msghdr,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_recv(
        arg1: socket_t,
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_recvfrom(
        arg1: socket_t,
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_send(
        arg1: socket_t,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_sendto(
        arg1: socket_t,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn acl_fiber_select(
        nfds: ::std::os::raw::c_int,
        readfds: *mut fd_set,
        writefds: *mut fd_set,
        exceptfds: *mut fd_set,
        timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_poll(
        fds: *mut pollfd,
        nfds: nfds_t,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_gethostbyname(name: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn acl_fiber_gethostbyname_r(
        name: *const ::std::os::raw::c_char,
        ent: *mut hostent,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        result: *mut *mut hostent,
        h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_getaddrinfo(
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acl_fiber_freeaddrinfo(res: *mut addrinfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACL_CHANNEL {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create one fiber channel"]
    #[doc = " @param elemsize {int} the fixed object size transfered in fiber channel"]
    #[doc = " @param bufsize {int} the buffered of objects in fiber channel"]
    #[doc = " @return {ACL_CHANNNEL*}"]
    pub fn acl_channel_create(
        elemsize: ::std::os::raw::c_int,
        bufsize: ::std::os::raw::c_int,
    ) -> *mut ACL_CHANNEL;
}
extern "C" {
    #[doc = " Free fiber channel created by acl_channel_create"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    pub fn acl_channel_free(c: *mut ACL_CHANNEL);
}
extern "C" {
    #[doc = " Send object to specified fiber channel in block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @param v {void*} the object to be transfered"]
    #[doc = " @return {int} value (>= 0) returned"]
    pub fn acl_channel_send(
        c: *mut ACL_CHANNEL,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send object to specified fiber channel in non-block mode, one new object"]
    #[doc = " copied from which will be created internal"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @param v {void*} the object to be transfered"]
    #[doc = " @return {int} value (>= 0) returned"]
    pub fn acl_channel_send_nb(
        c: *mut ACL_CHANNEL,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read one object from specified channel in block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @param v {void*} will store the result"]
    #[doc = " @return {int} value(>= 0) returned if get one object"]
    pub fn acl_channel_recv(
        c: *mut ACL_CHANNEL,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read one object from specified channel in non-block ode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @param v {void*} will store the result"]
    #[doc = " @return {int} value(>= 0) returned if get one object, or NULL returned if"]
    #[doc = "  none object been got"]
    pub fn acl_channel_recv_nb(
        c: *mut ACL_CHANNEL,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send object's addr to specified channel in block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @param v {void*} the addr of the object to be transfered"]
    #[doc = " @return {int} value (>= 0) returned"]
    pub fn acl_channel_sendp(
        c: *mut ACL_CHANNEL,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get object's addr from specified channel in block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @return {void*} non-NULL addr returned"]
    pub fn acl_channel_recvp(c: *mut ACL_CHANNEL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Send the object's addr to specified channel in non-block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @param v {void*} the addr of the object to be transfered"]
    #[doc = " @return {int} value which is >= 0 returned"]
    pub fn acl_channel_sendp_nb(
        c: *mut ACL_CHANNEL,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the object's addr form specified channel in non-block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @return {void*} * non-NULL returned when got one, or NULL returned"]
    pub fn acl_channel_recvp_nb(c: *mut ACL_CHANNEL) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Send unsigned integer to specified channel in block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @param val {unsigned long} the integer to be sent"]
    #[doc = " @return {int} value (>= 0) returned"]
    pub fn acl_channel_sendul(
        c: *mut ACL_CHANNEL,
        val: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get unsigned integer from specified channel in block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @return {unsigned long}"]
    pub fn acl_channel_recvul(c: *mut ACL_CHANNEL) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Sent unsigned integer to specified channel in non-block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @param val {unsigned long} integer to be sent"]
    #[doc = " @return {int} value(>= 0) returned"]
    pub fn acl_channel_sendul_nb(
        c: *mut ACL_CHANNEL,
        val: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get one unsigned integer from specified channel in non-block mode"]
    #[doc = " @param c {ACL_CHANNEL*} created by acl_channel_create"]
    #[doc = " @return {unsigned long}"]
    pub fn acl_channel_recvul_nb(c: *mut ACL_CHANNEL) -> ::std::os::raw::c_ulong;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
